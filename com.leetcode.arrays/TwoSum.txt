# Intuition
The problem requires us to find two indices in the array such that the numbers at those indices add up to the target value.
A straightforward way is to check all possible pairs of numbers and see if their sum equals the target.

# Approach
We loop through the array using two nested loops:
The outer loop picks the first number (nums[i]).
The inner loop picks the second number (nums[j]) where j > i.

For each pair (i, j), we check if nums[i] + nums[j] == target.
If we find a match, we return the indices [i, j].
If no such pair exists (though the problem guarantees one solution), we return an empty array.

This brute-force method ensures we check every possible pair in the array.

# Complexity
- **Time complexity:** The outer loop runs n-1 times, and the inner loop runs up to n-i-1 times.
So total iterations = O(n^2).

- **Space complexity:**
We only use a fixed-size result array (new int[]{i, j}), so O(1) extra space.

# Code
```java []
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i=0;i<nums.length-1;i++)
        {
            for(int j=i+1;j<nums.length;j++)
            {
                if(nums[i]+nums[j]==target)
                {
                    return new int[]{i,j};
                }
            }
            
        }
        return new int[]{};
    }
}
```

# Intuition

Instead of checking every possible pair (i, j), this code only checks pairs that are separated by exactly i distance in the array.
So for each i, the loop pairs up elements nums[j] with nums[j-i].
This reduces the number of comparisons, since weâ€™re not trying all combinations anymore, but only a subset.

# Approach
Start with i = 1 (distance between indices).
For each i, iterate j from i to n-1.
Pair elements at positions (j, j-i) and check if they add up to the target.

If yes, return those two indices.
If no match is found (though problem guarantees one solution), return an empty array.

# Complexity
**Time complexity:**
Outer loop runs n-1 times.
Inner loop runs n-i times for each i.
Total iterations = (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(nÂ²).

ðŸ‘‰ In worst case, itâ€™s still O(nÂ²).
But on average, this code may stop earlier (e.g., small i often finds the answer faster).

**Space complexity:**
Still O(1) extra space.

# Code
```java []
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i=1;i<nums.length;i++) {
            for(int j=i;j<nums.length;j++) {
                if(nums[j-i] + nums[j] == target) {
                    return new int[]{j, j-i};
                }
            }
        }
        return new int[]{};
    }
}
```

# Intuition

Instead of checking every pair, we can store numbers weâ€™ve already seen in a HashMap and check if the "complement" (the number we need to reach the target) exists.
This way, we only scan the array once.


# Approach

Initialize a HashMap:

key â†’ number from the array

value â†’ index of that number

Loop through the array:

For each nums[i], compute complement = target - nums[i].

If the complement is already in the map â†’ return [map.get(complement), i].

Otherwise, store nums[i] in the map with its index.

Since the problem guarantees exactly one solution, weâ€™ll always return inside the loop.

**Example 1**

Input: nums = [2, 7, 11, 15], target = 9

Steps:

i = 0 â†’ nums[i] = 2
complement = 9 - 2 = 7

Is 7 in map? âŒ No

Put (2, index 0) in map â†’ map = {2=0}

i = 1 â†’ nums[i] = 7
complement = 9 - 7 = 2

Is 2 in map? âœ… Yes â†’ map.get(2) = 0

Return [0, 1]

**Answer found: [0, 1]**

**Example 2**

Input: nums = [3, 2, 4], target = 6

Steps:

i = 0 â†’ nums[i] = 3
complement = 6 - 3 = 3

Is 3 in map? âŒ No

Put (3,0) â†’ map = {3=0}

i = 1 â†’ nums[i] = 2
complement = 6 - 2 = 4

Is 4 in map? âŒ No

Put (2,1) â†’ map = {3=0, 2=1}

i = 2 â†’ nums[i] = 4
complement = 6 - 4 = 2

Is 2 in map? âœ… Yes â†’ map.get(2) = 1

Return [1, 2]

**Answer found: [1, 2]**

# Complexity

**Time complexity:**
We loop through the array once, and each lookup in a HashMap is O(1) on average.
â†’ O(n)

**Space complexity:**
We store at most n elements in the HashMap.
â†’ O(n)

# Code
```java []
import java.util.HashMap;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            
            map.put(nums[i], i);
        }
        
        return new int[]{};
    }
}
```


